#!/usr/bin/env node
var Promise = require('bluebird');
var exec = require('child_process').exec;
var Table = require('cli-table2');
var fs = Promise.promisifyAll(require('fs'));
var grepArg;
if (process.argv.length < 3 ) {
    process.stderr.write('Must supply a search term (PID, process name)'); process.exit();
}
else {
    grepArg = process.argv[2];
}

function populateName(pid) {
    return new Promise(function(resolve, reject) {
        exec("cat /proc/" + pid + "/cmdline", function(error, stdout, stderr) {
            if (error || stderr) {
                reject(error || stderr);
            }
            //proc cmdline has null characters for spaces, but only non-trailing should be converted
            //otherwise it causes formatting issues with cli-table2 
            stdout = stdout.replace(/\0+$/,'');
            stdout = stdout.replace(/\0/g,' ');
            resolve(stdout);
        });
    });
}
function readProcFile(fileName, pid) {
    //always resolve because this function is being used to resolve a Promise.all
    return new Promise(function(resolve, reject) {
        var fullFile = `/proc/${pid}/${fileName}`;
        if (fileName !== 'cwd') {
            //reads a proc file - if fileName is cwd, it returns the symbolic link location.
            fs.readFileAsync(fullFile).then(function(fileResult) {
                //strip null chars / check for empty
                var fileBody = fileResult.toString().replace(/\0/g, '');
                if (fileBody.length) {
                    resolve({result: fileBody, error: false, pid: pid, fileName: fileName});
                }
                else {
                    resolve({result: '', error: true, pid: pid, fileName: fileName});
                }
            }).catch(function(err) {
                resolve({result: err, error: true, pid: pid, fileName: fileName});
            });
        }
        else {
            fs.readlinkAsync(fullFile).then(function(fileResult) {
                resolve({result: fileResult, error: false, pid: pid, fileName: fileName});
            }).catch(function(err) {
                resolve({result: err, error: true, pid: pid, fileName: fileName});
            });
        }
    });
}
function doAlphaSearch(grepArg) {
    return new Promise(function(resolve, reject) {
        buildPidHash().then(function(pidHash) {
            //search through the properties of the hash for something matching the grepArg.
            resolve(pidHash);
        });
    });
}
function buildPidHash() {
    return new Promise(function(resolve, reject) {
        exec("find /proc/ -maxdepth 1 -type d | cut -d '/' -f3-", function(error, stdout, stderr) {
            var filesToRead = [];
            var pidHash = {};
            if (error || stderr) {
                reject(error || stderr);
            }
            if (stdout) {
                var pids = stdout.split('\n');
                pids.forEach(function(pid, pidIndex) {
                   //filter out any non-digit dirs is /proc here - grep with extended or PCRL is only
                   //consistent on GNU Grep.
                   if (pid.match(/\D/) === null) {
                      filesToRead.push(readProcFile('cwd', pid));
                      filesToRead.push(readProcFile('cmdline', pid));
                   }
                });
                Promise.all(filesToRead).then(function(fileArr) {
                    fileArr.forEach(function(promiseResult) {
                        if (!promiseResult.error) {
                            if (!pidHash[promiseResult.pid]) {
                                pidHash[promiseResult.pid] = {};
                            }
                            var fileNameEval = promiseResult.fileName;
                            pidHash[promiseResult.pid][fileNameEval] = promiseResult.result;
                        }
                    });
                    resolve(pidHash);     
                });
            }
        });
    });
}
function doMain() {
    return new Promise(function(resolve, reject) {
        var isAlphaSearch = false;
        if (grepArg.match(/\D/) !== null) {
           isAlphaSearch = true; 
        }
        doAlphaSearch(grepArg).then(function(result) {
            console.log(result);
        }).catch(function(err) {
            console.log(err);
        });
        exec("ss -nlp | grep " + grepArg + " | tr -d [:blank:] | cut -d ':' -f2- | sed 's/^\:://g' | sort", function(error, stdout, stderr) {
            if (stderr) {
                process.stderr.write(stderr);
                process.exit();
            }
            var lines = stdout.split('\n');
            lines.pop();
            var line;
            var processHash = {};
            var numPopulated = 0;
            if (!lines.length) {
                resolve(processHash);
            }
            lines.forEach(function(line, key) {
                var port;
                var pid;
                var endPortPos = line.search(/\D/);
                if (endPortPos !== -1) {
                   port = line.substring(0, endPortPos); 
                }
                var parenIndex = line.indexOf('((');
                var endParenIndex = line.indexOf('))');
                pid = line.substring(parenIndex, endParenIndex);
                var firstCommaPos = pid.indexOf(',');
                var secondCommaPos = firstCommaPos + pid.substring(firstCommaPos+1).indexOf(',');
                pid = pid.substring(firstCommaPos+1, secondCommaPos + 1);
                processHash[port] = {pid: pid};
                //for each of the pids, look up the full name of the process
                //ye olde closure problem because we're in a for-loop
                populateName(pid).then(function(name) {
                    processHash[port].name = name;
                    numPopulated += 1;
                    if (numPopulated === lines.length) {
                        resolve(processHash);
                    }
                }).catch(function(err) {
                   reject(err); 
                });
            });
        });
    });
}
doMain().then(function(processHash) {
    var hashKeys = Object.keys(processHash);
    if (!hashKeys.length) {
       process.stdout.write('Nothing matched.'); 
       process.exit();
    }
    var table = new Table({
        head: ['Port', 'PID', 'Description'],
        colWidths: [8, 8, 70],
        style: {
            head: [],
            border: []
        }
    });
    for (var i = 0; i < hashKeys.length; i++) {
        table.push([hashKeys[i], processHash[hashKeys[i]].pid, processHash[hashKeys[i]].name]);
    }
    process.stdout.write(table.toString());
}).catch(function(err) {
    process.stderr.write(err);
});
